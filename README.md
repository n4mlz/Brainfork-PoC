# Brainfork

Brainfork は、Brainfuck の拡張であり、並列処理とロック機構を導入した新しいプログラミング言語です。この README では、Brainfork の基本的な構文と動作について説明します。

## 1. 追加記号と意味

| 記号                      | 意味                                                                                                                                                                                                                                                             |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \`{ ... \| ... \| ... }\` | 並列ブロック。`{` と `}` の間を `\|` で区切った各部分が **別スレッド**として同時に実行される。`}` で **全スレッドが終了するまで待機**（暗黙の join）。ネスト可。                                                                                                 |
| `(`                       | **ロック取得**。現在のデータポインタが指すセルをロックする。取得できるのは、他スレッドがそのセルを保持していない場合のみ。取得成功で続行、取得済みならそのスレッドはブロックされる。セルの値は一切変更しない。ロックしたセルの位置は内部スタックに push される。 |
| `)`                       | **ロック解放**。内部スタックのトップにあるセルを解放する（対応する `(` に対する解放）。データポインタをそのセルに戻す必要はない。スタックが空ならエラー。                                                                                                        |
| `~`                       | **待機**。実行中のスレッドを 0.1 秒（固定値）停止させる。複数並べればその分だけ待つ（例：`~~~` → 0.3 秒）。                                                                                                                                                      |
| `;`                       | **コメント**。行内の `;` 以降、改行（または入力終端）まで無視する。コメント中の `{`, `(` などは対応関係チェックの対象外。                                                                                                                                        |

---

## 2. ロックのルール

- ロック対象は「`(` を実行した瞬間のセル（インデックス）」。
- ロック状態は **ランタイム内部で管理**し、セル値は変更しない。
- **取得条件**: そのセルがどのスレッドからもロックされていないこと。
- **解放順序**: ロックは **取得した逆順**でのみ解放できる（スタック方式）。
  つまり、直前に取得したロックを先に解放する必要がある。
- 解放対象セルへデータポインタを戻す必要はない。`)` は常にトップを解放する。

---

## 3. 並列ブロックの動作

```
{ CODE_A | CODE_B | CODE_C }
```

- `CODE_A`, `CODE_B`, `CODE_C` がそれぞれ独立したスレッドとして開始。
- 親スレッドは `}` に到達したとき、3 スレッドすべての終了を待ってから先へ進む。
- ブロック内部でさらに `{}` をネスト可能。

---

## 4. スレッドとスケジューリング

- 各スレッドは独立した命令ポインタとデータポインタを持つ。
  （テープ自体は共有）
- スケジューリング方式（ラウンドロビン等）は未規定。待機・ブロック中のスレッドはスケジューラにより再開される。
- ロック待ちや `~` により意図的に他スレッドへ CPU を渡すことができる。
- `;` 以降はパーサ段階で取り除かれるため、実行・同期・対応関係判定には影響しない。

---

## 5. エラーと未定義動作

- **エラー**（少なくとも実装依存で検出推奨）

  - `)` 実行時にロックスタックが空。
  - `)` で解放対象が他スレッドのロックだった場合（実装で検出可能ならエラー）。

- **未定義動作**

  - 仕様で明示していない例外的なケース（例：ロック中セルを他手段で無理やり操作するなど）は実装依存にして良い。

---

## 6. メモリ可視性（簡易ルール）

- `(` は **acquire フェンス**として扱い、以降の読み取りは他スレッドの解放前書き込みを正しく観測できる。
- `)` は **release フェンス**として扱い、解放前に行った書き込みは他スレッドが次にそのセルをロック取得したときに観測可能。
- ロックで保護されない共有セルへの同時書き込みの結果は未定義。

---

## 7. 例

### 例 1: 2 スレッドで同じセルを安全にインクリメント

```
>[-]        ; cell1 をロック用セルとして使う（値自体は変えない方針だが初期化は可）
<[-]        ; cell0 をカウンタ 0 に

{           ; 並列に 2 スレッド
  (         ; cell0 をロック
    +       ; クリティカルセクション: cell0++
  )         ; ロック解放
|
  (
    +
  )
}
```

### 例 2: 2 つのセルを順にロックして操作（LIFO で解放）

```
(        ; lock cell0
> (      ; lock cell1
< + > +  ; 操作 (cell0++, cell1++)
)        ; unlock cell1
)        ; unlock cell0
```

### 例 3: デッドロックを意図的に発生させ得るコード（説明用）

```
{              ; Thread A
  ( > (        ; lock cell0, then cell1
    ...
  ) )          ; unlock cell1, then cell0
|
  > ( < (      ; lock cell1 first, then cell0  ← 逆順取得
    ...
  ) )          ; unlock cell0, then cell1
}
```

- 上記のように、異なる順序で複数セルをロックすると相互待機が起きうる。
- `~` を挿入してタイミングを変えることで再現性を上げられる。

---

## 8. まとめ（ポイント再掲）

- **追加記号**: `{`, `}`, `|`, `(`, `)`, `~`, `;`
- **コメント**: `;` から行末まで無視。
- **並列化**: `{ ... | ... }` で複数スレッド実行、`}` で合流。
- **ロック**: `(` で現在セルをロック、`)` で最後にロックしたセルを解放（逆順必須）。セル値は変更しない。
- **待機**: `~` で 0.1 秒スリープ。
- **デッドロック**: 発生しうる。回避はユーザ責任（取得順序を統一する等）。
- **エラー処理**: 不正な解除などは実装側で検出し、エラーとすることを推奨。
